<!DOCTYPE html>
        <html lang="en">
        <head>
          <meta charset="UTF-8" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <title>Meal Details</title>
          <script src="https://cdn.tailwindcss.com"></script>
          <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
          <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-database-compat.js"></script>
          <style>
           body {
      background-color: #0f172a;
      color: #f8fafc;
      font-family: 'Segoe UI', sans-serif;
      padding: 1.5rem;
    }

    .container {
      max-width: 900px;
      margin: auto;
      padding: 2rem;
      background-color: #1e293b;
      border-radius: 1.5rem;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
    }

    .section-box {
      background-color: #334155;
      padding: 1.5rem;
      border-radius: 1rem;
      margin-bottom: 2rem;
    }

    .section-title {
      font-size: 1.5rem;
      font-weight: 600;
      margin-bottom: 1rem;
      text-transform: capitalize;
      color: #f1f5f9;
    }

    .btn {
      background-color: #22c55e;
      color: white;
      font-weight: bold;
      padding: 0.6rem 1.5rem;
      border-radius: 0.75rem;
      border: none;
      cursor: pointer;
      transition: 0.3s ease-in-out;
      display: inline-block;
    }

    .btn:hover {
      background-color: #16a34a;
    }

    .edit-btn,
    .delete-btn {
      background-color: transparent;
      color: #94a3b8;
      font-size: 0.9rem;
      margin-left: 1rem;
      cursor: pointer;
      text-decoration: underline;
    }

    .textarea,
    .input {
      background-color: #1e293b;
      color: #f8fafc;
      border: 1px solid #475569;
      border-radius: 0.5rem;
      padding: 0.75rem;
      width: 100%;
      margin-bottom: 1rem;
    }

    .textarea:focus,
    .input:focus {
      outline: none;
      border-color: #22c55e;
    }

    .ingredient-list {
      list-style: disc;
      padding-left: 1.5rem;
    }

    .method-list {
      list-style: decimal;
      padding-left: 1.5rem;
    }

    .rating-stars {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 1rem;
    }

    .star {
      font-size: 2rem;
      cursor: pointer;
      color: #64748b;
      transition: transform 0.2s ease;
    }

    .star:hover {
      transform: scale(1.1);
    }

    .star.filled {
      color: #facc15;
    }

    .comment {
      background-color: #1e293b;
      padding: 0.75rem;
      border-radius: 0.5rem;
      margin-bottom: 0.5rem;
      position: relative;
    }

    .comment-actions {
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
    }

    .timestamp {
      font-size: 0.75rem;
      color: #94a3b8;
    }

    @media (max-width: 600px) {
      .star {
        font-size: 1.5rem;
      }
    }

    .toast {
      position: fixed;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      background-color: #22c55e;
      color: white;
      padding: 0.8rem 1.5rem;
      border-radius: 1rem;
      display: none;
    }

    .toast.show {
      display: block;
    }

    .back-button {
      display: block;
      text-align: center;
      margin-top: 2rem;
    }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="section-box text-center">
              <h1 class="text-3xl font-bold text-green-400" id="mealName">meal name</h1>
            </div>

            <div class="section-box">
              <div class="flex justify-between items-center">
                <h2 class="section-title">meal description</h2>
                <button id="editDescriptionBtn" class="edit-btn">edit</button>
              </div>
              <div id="mealDescriptionText" class="mb-2"></div>
              <textarea id="mealDescriptionInput" class="textarea hidden" rows="4"></textarea>
              <button id="saveDescriptionBtn" class="btn hidden">save</button>
            </div>

            <div class="section-box">
              <div class="flex justify-between items-center">
                <h2 class="section-title">ingredients</h2>
                <button id="editIngredientsBtn" class="edit-btn">edit</button>
              </div>
              <ul id="ingredientsList" class="ingredient-list"></ul>
              <textarea id="ingredientsInput" class="textarea hidden" rows="4" placeholder="Add each ingredient separated by comma"></textarea>
              <button id="saveIngredientsBtn" class="btn hidden">save</button>
            </div>

            <div class="section-box">
              <div class="flex justify-between items-center">
                <h2 class="section-title">method</h2>
                <button id="editMethodBtn" class="edit-btn">edit</button>
              </div>
              <ol id="methodList" class="method-list"></ol>
              <textarea id="methodInput" class="textarea hidden" rows="4" placeholder="Add each step separated by comma"></textarea>
              <button id="saveMethodBtn" class="btn hidden">save</button>
            </div>

            <div class="section-box">
              <h2 class="section-title">rate this meal</h2>
              <div class="rating-stars" id="starsContainer"></div>
              <p class="text-center mt-4 text-lg font-semibold" id="avgRating">average rating: loading...</p>
              <p id="errorMessage" class="text-red-400 text-center mt-2"></p>
            </div>

            <div class="section-box">
              <h2 class="section-title">family comments</h2>
              <textarea id="commentInput" class="textarea" placeholder="write your comment..."></textarea>
              <button id="saveCommentBtn" class="btn mb-4">save comment</button>
              <div id="commentsList"></div>
            </div>

            <a href="index.html" class="btn block text-center back-button">← back to meal planner</a>
          </div>

          <div id="toast" class="toast">Changes saved!</div>
          <script>
            const firebaseConfig = {
                apiKey: "AIzaSyDggOxw9S18mf4l-PqkMqVg3YYGc612tQA",
                authDomain: "meal-b14ca.firebaseapp.com",
                databaseURL: "https://meal-b14ca-default-rtdb.europe-west1.firebasedatabase.app",
                projectId: "meal-b14ca",
                storageBucket: "meal-b14ca.appspot.com",
                messagingSenderId: "190610959035",
                appId: "1:190610959035:web:6d078d26d0e7e07c86979e"
            };
          
            firebase.initializeApp(firebaseConfig);
            const db = firebase.database();
            const mealNameFromURL = new URLSearchParams(window.location.search).get('meal');
            const mealRef = db.ref(`foodGroups/${mealNameFromURL}`); // Use the URL name here
            let mealData = {};
            let userRating = null;
            let userId = 'anonymous-user'; // Replace with actual user ID if you have authentication
          
            const mealNameEl = document.getElementById('mealName');
            const descText = document.getElementById('mealDescriptionText');
            const descInput = document.getElementById('mealDescriptionInput');
            const saveDescBtn = document.getElementById('saveDescriptionBtn');
            const editDescBtn = document.getElementById('editDescriptionBtn');
          
            const ingredientsList = document.getElementById('ingredientsList');
            const ingredientsInput = document.getElementById('ingredientsInput');
            const saveIngredientsBtn = document.getElementById('saveIngredientsBtn');
            const editIngredientsBtn = document.getElementById('editIngredientsBtn');
          
            const methodList = document.getElementById('methodList');
            const methodInput = document.getElementById('methodInput');
            const saveMethodBtn = document.getElementById('saveMethodBtn');
            const editMethodBtn = document.getElementById('editMethodBtn');
          
            const starsContainer = document.getElementById('starsContainer');
            const avgRatingEl = document.getElementById('avgRating');
            const errorMessage = document.getElementById('errorMessage');
            const commentInput = document.getElementById('commentInput');
            const saveCommentBtn = document.getElementById('saveCommentBtn');
            const commentsList = document.getElementById('commentsList');
            const toast = document.getElementById('toast');
          
            const commentsCache = {}; // Object to store loaded comments with their keys
            const RATED_KEY_PREFIX = `meal_${mealNameFromURL}_rated`;
          
            function checkIfAlreadyRated() {
                return localStorage.getItem(RATED_KEY_PREFIX) === 'true';
            }
          
            function markAsRated() {
                localStorage.setItem(RATED_KEY_PREFIX, 'true');
            }
          
            mealRef.once('value', (snapshot) => {
                mealData = snapshot.val();
                updateMealPage();
                displayRatingInfo();
                loadAndListenForComments();
            });
          
            function updateMealPage() {
                mealNameEl.textContent = mealNameFromURL || 'Meal Name'; // Use the URL name here
                descText.textContent = mealData ? mealData.description || '' : '';
                descInput.value = mealData ? mealData.description || '' : '';
                ingredientsInput.value = mealData && mealData.ingredients ? mealData.ingredients.join(',') : '';
                ingredientsList.innerHTML = mealData && mealData.ingredients
                    ? mealData.ingredients.map(ingredient => `<li>${ingredient.trim()}</li>`).join('')
                    : '';
                methodInput.value = mealData && mealData.method ? mealData.method.join(',') : '';
                methodList.innerHTML = mealData && mealData.method
                    ? mealData.method.map(step => `<li>${step.trim()}</li>`).join('')
                    : '';
                setupRatingStars();
            }
          
            function highlightStars(rating) {
                document.querySelectorAll('#starsContainer .star').forEach(star => {
                    const starValue = parseInt(star.dataset.rating);
                    star.classList.toggle('filled', starValue <= rating);
                });
            }
          
            function resetStars() {
                document.querySelectorAll('#starsContainer .star').forEach(star => {
                    star.classList.remove('filled');
                    if (userRating && parseInt(userRating) >= parseInt(star.dataset.rating)) {
                        star.classList.add('filled');
                    } else if (mealData.ratings && mealData.ratings[userId] && parseInt(mealData.ratings[userId]) >= parseInt(star.dataset.rating)) {
                        star.classList.add('filled');
                    }
                });
            }
          
            function setupRatingStars() {
                starsContainer.innerHTML = '';
                for (let i = 1; i <= 5; i++) {
                    const star = document.createElement('span');
                    star.className = 'star';
                    star.textContent = '★';
                    star.dataset.rating = i;
                    star.addEventListener('click', handleStarClick);
                    star.addEventListener('mouseover', () => highlightStars(i));
                    star.addEventListener('mouseout', resetStars);
                    starsContainer.appendChild(star);
                }
                highlightStars(userRating || (mealData.ratings && mealData.ratings[userId]));
            }
          
            function handleStarClick(event) {
                if (checkIfAlreadyRated()) {
                    errorMessage.textContent = "You have already rated this meal.";
                    setTimeout(() => {
                        errorMessage.textContent = "";
                    }, 3000);
                    return;
                }
          
                const rating = parseInt(event.target.dataset.rating);
                userRating = rating;
                db.ref(`foodGroups/${mealNameFromURL}/ratings/${userId}`).set(rating);
                displayRatingInfo();
                highlightStars(rating);
                toast.classList.add('show');
                setTimeout(() => {
                    toast.classList.remove('show');
                }, 2000);
                markAsRated(); // Mark that this device has now rated
            }
          
            function displayRatingInfo() {
                const ratingsRef = mealRef.child('ratings');
                ratingsRef.once('value', (snapshot) => {
                    let totalRating = 0;
                    let voteCount = 0;
                    const userRatings = {};
                    let uniqueVoters = 0;
          
                    snapshot.forEach((userSnapshot) => {
                        const rating = userSnapshot.val();
                        totalRating += rating;
                        userRatings[userSnapshot.key] = true;
                        uniqueVoters++;
                    });
          
                    const averageRating = uniqueVoters > 0 ? (totalRating / uniqueVoters).toFixed(1) : 'Not yet rated';
                    const hasRatedLocal = checkIfAlreadyRated();
                    const yourRatingText = hasRatedLocal
                        ? (userRating || (mealData.ratings && mealData.ratings[userId]) || 'Rated')
                        : (userRating || (mealData.ratings && mealData.ratings[userId]) || 'Not yet rated');
          
                    avgRatingEl.textContent = `Your Rating: ${yourRatingText} (${uniqueVoters} unique voters)`;
                    highlightStars(userRating || (mealData.ratings && mealData.ratings[userId]));
                });
            }
          
            function loadAndListenForComments() {
                commentsList.innerHTML = '';
                const commentsRef = mealRef.child('comments').orderByChild('timestamp');
                for (const key in commentsCache) {
                    delete commentsCache[key];
                }
          
                commentsRef.once('value', (snapshot) => {
                    snapshot.forEach((childSnapshot) => {
                        const commentData = childSnapshot.val();
                        const commentKey = childSnapshot.key;
                        addCommentToUI(commentData, commentKey);
                        commentsCache[commentKey] = commentData; // Store in cache
                    });
                    startCommentListeners();
                });
            }
          
            function startCommentListeners() {
                const commentsRef = mealRef.child('comments');
          
                commentsRef.on('child_added', (snapshot) => {
                    const commentData = snapshot.val();
                    const commentKey = snapshot.key;
                    if (!commentsCache[commentKey]) { // Only add if not already in cache (prevent duplicates on initial load)
                        addCommentToUI(commentData, commentKey);
                        commentsCache[commentKey] = commentData;
                    }
                });
          
                commentsRef.on('child_changed', (snapshot) => {
                    const commentData = snapshot.val();
                    const commentKey = snapshot.key;
                    commentsCache[commentKey] = commentData; // Update cache
                    const commentTextEl = document.getElementById(`commentText-${commentKey}`);
                    if (commentTextEl) {
                        commentTextEl.textContent = commentData.comment;
                    }
                });
          
                commentsRef.on('child_removed', (snapshot) => {
                    const commentKey = snapshot.key;
                    delete commentsCache[commentKey]; // Remove from cache
                    const commentElToRemove = commentsList.querySelector(`.comment[data-key="${commentKey}"]`);
                    if (commentElToRemove) {
                        commentElToRemove.remove();
                    }
                });
            }
          
            function addCommentToUI(commentData, commentKey) {
                const commentEl = document.createElement('div');
                commentEl.classList.add('comment');
                commentEl.dataset.key = commentKey; // Ensure the key is directly on the comment element
                commentEl.innerHTML = `
                  <p id="commentText-${commentKey}">${commentData.comment}</p>
                  <textarea id="commentInput-${commentKey}" class="textarea hidden">${commentData.comment}</textarea>
                  <p class="timestamp">${new Date(commentData.timestamp).toLocaleString()}</p>
                  <div class="comment-actions">
                    <button class="edit-btn" data-key="${commentKey}">Edit</button>
                    <button class="delete-btn" data-key="${commentKey}">Delete</button>
                    <button class="btn hidden save-edit-btn" data-key="${commentKey}">Save</button>
                  </div>
                `;
                commentsList.appendChild(commentEl);
            }
          
            saveCommentBtn.addEventListener('click', () => {
                console.log("Save comment button clicked!"); // Debug log
                const newComment = commentInput.value.trim();
                console.log("Comment text:", newComment); // Debug log
                if (newComment) {
                    console.log("Comment is not empty, attempting to save to Firebase..."); // Debug log
                    const commentRef = mealRef.child('comments').push();
                    commentRef.set({
                        comment: newComment,
                        timestamp: new Date().toISOString()
                    }).then(() => {
                        console.log("Comment saved successfully to Firebase."); // Success log
                        commentInput.value = '';
                    }).catch((error) => {
                        console.error("Error saving comment to Firebase:", error); // Error log
                    });
                } else {
                    console.log("Comment is empty, not saving."); // Log for empty comment
                }
            });
          
            commentsList.addEventListener('click', (event) => {
                console.log("Clicked element:", event.target);
                const commentKey = event.target.dataset.key;
                console.log("Comment key:", commentKey);
                const target = event.target;
          
                if (target.classList.contains('delete-btn')) {
                    deleteComment(commentKey);
                } else if (target.classList.contains('edit-btn')) {
                    enableEditComment(commentKey);
                } else if (target.classList.contains('save-edit-btn')) {
                    saveEditedComment(commentKey);
                }
            });
          
            function deleteComment(commentKey) {
                mealRef.child('comments').child(commentKey).remove();
            }
          
            function enableEditComment(commentKey) {
                const commentTextEl = document.getElementById(`commentText-${commentKey}`);
                const commentInputEl = document.getElementById(`commentInput-${commentKey}`);
                const editBtn = commentsList.querySelector(`.edit-btn[data-key="${commentKey}"]`);
                const deleteBtn = commentsList.querySelector(`.delete-btn[data-key="${commentKey}"]`);
                const saveEditBtn = commentsList.querySelector(`.save-edit-btn[data-key="${commentKey}"]`);
          
                if (commentTextEl && commentInputEl && editBtn && deleteBtn && saveEditBtn) {
                    commentTextEl.classList.add('hidden');
                    commentInputEl.classList.remove('hidden');
                    editBtn.classList.add('hidden');
                    deleteBtn.classList.add('hidden');
                    saveEditBtn.classList.remove('hidden');
                }
            }
          
            function saveEditedComment(commentKey) {
                const commentInputEl = document.getElementById(`commentInput-${commentKey}`);
                const commentTextEl = document.getElementById(`commentText-${commentKey}`);
                const editBtn = commentsList.querySelector(`.edit-btn[data-key="${commentKey}"]`);
                const deleteBtn = commentsList.querySelector(`.delete-btn[data-key="${commentKey}"]`);
                const saveEditBtn = commentsList.querySelector(`.save-edit-btn[data-key="${commentKey}"]`);
          
                if (commentInputEl && commentTextEl && editBtn && deleteBtn && saveEditBtn) {
                    const editedComment = commentInputEl.value.trim();
                    if (editedComment) {
                        mealRef.child('comments').child(commentKey).update({ comment: editedComment });
                        commentTextEl.textContent = editedComment;
                        commentTextEl.classList.remove('hidden');
                        commentInputEl.classList.add('hidden');
                        editBtn.classList.remove('hidden');
                        deleteBtn.classList.remove('hidden');
                        saveEditBtn.classList.add('hidden');
                    } else {
                        alert('Comment cannot be empty.');
                    }
                }
            }
          
            // EDIT FUNCTIONALITY FOR DESCRIPTION
            editDescBtn.addEventListener('click', () => toggleDescriptionEdit(true));
          
            function toggleDescriptionEdit(showEdit) {
                console.log("toggleDescriptionEdit called with:", showEdit);
                descInput.classList.toggle('hidden', !showEdit);
                saveDescBtn.classList.toggle('hidden', !showEdit);
                editDescBtn.classList.toggle('hidden', showEdit);
                descText.classList.toggle('hidden', showEdit);
            }
          
            saveDescBtn.addEventListener('click', () => {
                mealRef.update({ description: descInput.value });
                descText.textContent = descInput.value;
                toggleDescriptionEdit(false);
            });
          
            // EDIT FUNCTIONALITY FOR INGREDIENTS
            editIngredientsBtn.addEventListener('click', () => toggleIngredientsEdit(true));
          
            function toggleIngredientsEdit(showEdit) {
                console.log("toggleIngredientsEdit called with:", showEdit);
                ingredientsInput.classList.toggle('hidden', !showEdit);
                saveIngredientsBtn.classList.toggle('hidden', !showEdit);
                editIngredientsBtn.classList.toggle('hidden', showEdit);
                ingredientsList.classList.toggle('hidden', showEdit);
                if (showEdit) {
                    ingredientsInput.value = mealData.ingredients ? mealData.ingredients.join(',') : '';
                }
            }
          
            saveIngredientsBtn.addEventListener('click', () => {
                const newIngredients = ingredientsInput.value.split(',').map(item => item.trim()).filter(item => item);
                mealRef.update({ ingredients: newIngredients });
                ingredientsList.innerHTML = newIngredients.map(ingredient => `<li>${ingredient}</li>`).join('');
                toggleIngredientsEdit(false);
            });
          
            // EDIT FUNCTIONALITY FOR METHOD
            editMethodBtn.addEventListener('click', () => toggleMethodEdit(true));
          
            function toggleMethodEdit(showEdit) {
                console.log("toggleMethodEdit called with:", showEdit);
                methodInput.classList.toggle('hidden', !showEdit);
                saveMethodBtn.classList.toggle('hidden', !showEdit);
                editMethodBtn.classList.toggle('hidden', showEdit);
                methodList.classList.toggle('hidden', showEdit);
                if (showEdit) {
                    methodInput.value = mealData.method ? mealData.method.join(',') : '';
                }
            }
          
            saveMethodBtn.addEventListener('click', () => {
                const newMethod = methodInput.value.split(',').map(item => item.trim()).filter(item => item);
                mealRef.update({ method: newMethod });
                methodList.innerHTML = newMethod.map((step, index) => `<li>${step}</li>`).join('');
                toggleMethodEdit(false);
            });
          
            window.addEventListener('load', () => {
                if (checkIfAlreadyRated()) {
                    // If already rated, try to show the user's existing rating if available
                    const storedRating = mealData.ratings && mealData.ratings[userId];
                    if (storedRating) {
                        highlightStars(storedRating);
                    } else {
                        // If rated but no user-specific rating found (e.g., anonymous user),
                        // just show the filled stars based on a general "rated" state.
                        highlightStars(0); // Or some other visual indication
                    }
                }
            });
          </script>
        </body>
        </html>